import pandas as pd
import numpy as np
import tkinter as tk
from tkinter import filedialog, messagebox
import os
import sys
import json
from jinja2 import Template
import webbrowser

# --- Configuration File Name ---
CONFIG_FILE = 'config.json'

# --- HTML Template for Bootstrap Report ---
# Ce mod√®le HTML est stock√© en Python pour √™tre inclus dans l'ex√©cutable PyInstaller
HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analysis Report ({{ report_title }})</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body { padding: 20px; }
        .table-responsive { max-height: 80vh; overflow-y: auto; }
        .header-section { margin-bottom: 30px; }
        .error-found { font-weight: bold; color: #dc3545; }
        .no-error { font-weight: bold; color: #198754; }
    </style>
</head>
<body>
    <div class="container-fluid">
        <div class="header-section text-center">
            <h1 class="display-5">üèÅ Analysis Report: {{ report_title }}</h1>
            <p class="text-muted">Generated by Script | Junior Max Year: {{ max_year }}</p>
            <hr>
            {% if error_count > 0 %}
                <h2 class="error-found">üö® {{ error_count }} Error(s) Detected üö®</h2>
                <p>The detailed list is below and saved to <code>{{ report_csv_name }}</code> and <code>{{ report_html_name }}</code>.</p>
            {% else %}
                <h2 class="no-error">‚úÖ No Errors Detected ‚úÖ</h2>
                <p>The analysis of valid data is complete.</p>
            {% endif %}
            <hr>
        </div>

        {% if error_count > 0 %}
            <div class="table-responsive">
                <table class="table table-striped table-hover table-sm">
                    <thead class="table-dark sticky-top">
                        <tr>
                            {% for col in columns %}
                                <th>{{ col }}</th>
                            {% endfor %}
                        </tr>
                    </thead>
                    <tbody>
                        {% for row in data %}
                            <tr class="{% if 'Gender' in row.Mistake_type %}table-danger{% elif 'Category' in row.Mistake_type %}table-warning{% endif %}">
                                {% for cell in row.values() %}
                                    <td>{{ cell }}</td>
                                {% endfor %}
                            </tr>
                        {% endfor %}
                    </tbody>
                </table>
            </div>
        {% endif %}
    </div>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>
"""

# --- Parameter Loading Function (Modified for PyInstaller) ---
def load_parameters():
    """Loads configuration parameters from the JSON file, supporting PyInstaller bundles."""
    
    # 1. Determine the correct path for CONFIG_FILE
    # Check if the script is running inside a PyInstaller bundle
    if getattr(sys, 'frozen', False):
        # The path is relative to the executable's temporary directory (_MEIPASS)
        base_path = sys._MEIPASS
    else:
        # The path is the script's directory
        base_path = os.path.dirname(os.path.abspath(__file__))
        
    config_full_path = os.path.join(base_path, CONFIG_FILE)
    
    # 2. Check if the file exists
    if not os.path.exists(config_full_path):
        print(f"‚ùå Error: Configuration file '{CONFIG_FILE}' not found at {config_full_path}.")
        print("Please ensure the file is in the same directory as the executable/script.")
        sys.exit(1)
    
    # 3. Load the configuration
    try:
        with open(config_full_path, 'r', encoding='utf-8') as f:
            config = json.load(f)
        
        required_keys = ['ANNEE_MAX_JUNIOR', 'DELIMITER', 'COLUMNS_NAMES_SOURCE']
        if not all(key in config for key in required_keys):
             print(f"‚ùå Error: The file '{CONFIG_FILE}' does not contain all required parameters.")
             sys.exit(1)
             
        return config

    except json.JSONDecodeError:
        print(f"‚ùå Error: The file '{CONFIG_FILE}' is not valid JSON.")
        sys.exit(1)
    except Exception as e:
        print(f"‚ùå Error loading parameters: {e}")
        sys.exit(1)

# Load parameters globally
CONFIG = load_parameters()
ANNEE_MAX_JUNIOR = CONFIG['ANNEE_MAX_JUNIOR']
DELIMITER = CONFIG['DELIMITER']
COLUMNS_NAMES_SOURCE = CONFIG['COLUMNS_NAMES_SOURCE']

ENCODINGS = ['utf-8', 'latin-1', 'cp1252'] 

# --- File Selection Function ---
def select_file() -> str:
    """Opens a dialog to select a CSV file."""
    try:
        root = tk.Tk()
        root.withdraw() 
    except Exception:
        print("‚ùå Critical Error: Failed to initialize Tkinter.")
        sys.exit(1)
        
    file_path = filedialog.askopenfilename(
        title="Select the CSV results file",
        filetypes=(("CSV files", "*.csv"), ("All files", "*.*"))
    )
    
    if not file_path:
        sys.exit(0)
        
    return file_path

# --- Main Analysis Function ---

def analyze_and_report_errors(file_path: str):
    """Loads the file, applies section context, detects errors, and creates the reports (CSV & HTML)."""
    
    file_name = os.path.basename(file_path)
    base, ext = os.path.splitext(file_path)
    
    # Define report file names (will be saved next to the source file)
    output_csv_full_path = f"{base}_analysis.csv"
    output_html_full_path = f"{base}_report.html"
    
    output_csv_name = os.path.basename(output_csv_full_path)
    output_html_name = os.path.basename(output_html_full_path)
    
    error_count = 0
    
    # Try to load the DataFrame
    df_raw = None
    for encoding in ENCODINGS:
        try:
            df_raw = pd.read_csv(file_path, delimiter=DELIMITER, header=None, encoding=encoding)
            break
        except Exception:
            continue
    
    if df_raw is None:
        messagebox.showerror("Execution Error", f"‚ùå Critical Error: Failed to load file with configured delimiter '{DELIMITER}'.")
        return

    df = pd.DataFrame() 

    # 1. DataFrame Preparation
    num_cols_read = df_raw.shape[1]
    if num_cols_read < len(COLUMNS_NAMES_SOURCE):
        messagebox.showerror("Execution Error", f"‚ùå Critical Error: Read file has only {num_cols_read} columns. {len(COLUMNS_NAMES_SOURCE)} expected.")
        return
    
    df_raw.columns = COLUMNS_NAMES_SOURCE + [f'extra_{i}' for i in range(num_cols_read - len(COLUMNS_NAMES_SOURCE))]
    df_raw = df_raw[COLUMNS_NAMES_SOURCE].copy()
    
    
    # 2. Identify and Apply Section Context
    df_raw['context_discipline'] = '' 
    df_raw['context_gender'] = ''
    df_raw['context_category'] = ''
    
    current_discipline = None
    current_gender = None
    current_category = None
    
    for index, row in df_raw.iterrows():
        if str(row['athlete_id']).strip() == '*':
            current_discipline = str(row['discipline']).lower().strip()
            current_gender = str(row['gender']).lower().strip()
            current_category = str(row['category']).lower().strip()
        
        df_raw.loc[index, 'context_discipline'] = current_discipline if current_discipline else ''
        df_raw.loc[index, 'context_gender'] = current_gender if current_gender else ''
        df_raw.loc[index, 'context_category'] = current_category if current_category else ''

    
    # 3. Filter Valid Data Rows
    try:
        df = df_raw[
            df_raw['athlete_id'].astype(str).str.match(r'^[12]', na=False) &
            (df_raw['context_gender'] != '')
        ].copy()
    except Exception as e:
        messagebox.showerror("Execution Error", f"‚ùå Critical Error: Data filtering failed: {e}")
        return

    if df.empty:
        messagebox.showinfo("Analysis Result", "‚úÖ Analysis complete: No valid athlete data found.")
        return

    # 4. Error Detection
    df['athlete_id_str'] = df['athlete_id'].astype(str)
    df['code_genre'] = df['athlete_id_str'].str[0]
    df['annee_naissance'] = pd.to_numeric(df['athlete_id_str'].str[1:5], errors='coerce') 
    
    # Gender Error
    gender_error_condition = (
        (df['code_genre'] == '1') & (df['context_gender'] == 'woman') | 
        (df['code_genre'] == '2') & (df['context_gender'] == 'man')    
    )
    df['erreur_genre'] = gender_error_condition
    
    # Category Error 
    df['categorie_reelle'] = np.where(df['annee_naissance'] >= ANNEE_MAX_JUNIOR, 'junior', 'senior')
    
    category_error_condition = (
        (df['categorie_reelle'] == 'junior') & (df['context_category'] == 'senior') | 
        (df['categorie_reelle'] == 'senior') & (df['context_category'] == 'junior')   
    )
    df['erreur_categorie'] = category_error_condition

    df['is_in_error'] = df['erreur_genre'] | df['erreur_categorie']
    erreurs_df = df[df['is_in_error']].copy()


    # 5. Report Preparation and Saving
    
    error_count = len(erreurs_df)
    
    if erreurs_df.empty:
        messagebox.showinfo("Analysis Result", "‚úÖ Analysis complete: No errors found.")
        return
        
    # Create final columns for reports
    erreurs_df['Mistake_type'] = ''
    erreurs_df.loc[erreurs_df['erreur_genre'], 'Mistake_type'] += 'Gender; '
    erreurs_df.loc[erreurs_df['erreur_categorie'], 'Mistake_type'] += 'Category; '
    erreurs_df['Mistake_type'] = erreurs_df['Mistake_type'].str.strip('; ')

    erreurs_df['real_gender'] = erreurs_df['code_genre'].replace({'1': 'man', '2': 'woman'})
    erreurs_df['real_category'] = erreurs_df['categorie_reelle']
    
    raw_columns_to_export = [
        'context_discipline', 
        'athlete_id', 
        'context_gender', 
        'context_category', 
        'real_gender', 
        'real_category', 
        'Mistake_type'
    ]
    
    final_report_columns = [
        'discipline', 
        'athlete_id', 
        'context_gender', 
        'context_category', 
        'real_gender', 
        'real_category', 
        'Mistake_type'
    ]
    
    df_export = erreurs_df[raw_columns_to_export].copy()
    df_export = df_export.rename(columns={'context_discipline': 'discipline'})
    
    # --- 5a. Save CSV Report ---
    try:
        df_export[final_report_columns].to_csv(
            output_csv_full_path, 
            index=False, 
            sep=DELIMITER, 
            encoding='utf-8-sig'
        )
    except Exception as e:
        messagebox.showerror("Execution Error", f"‚ùå Critical Error: Failed to create CSV report: {e}")
        return

    # --- 5b. Generate and Save HTML Report ---
    try:
        # Prepare data for Jinja2 template
        data_for_html = df_export[final_report_columns].to_dict('records')
        
        template = Template(HTML_TEMPLATE)
        html_content = template.render(
            report_title=file_name,
            max_year=ANNEE_MAX_JUNIOR,
            error_count=error_count,
            report_csv_name=output_csv_name,
            report_html_name=output_html_name,
            columns=final_report_columns,
            data=data_for_html
        )
        
        with open(output_html_full_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        # --- 5c. Show Pop-up and Open HTML ---
        messagebox.showinfo(
            "Analysis Complete", 
            f"üö® Analysis complete: {error_count} error(s) found.\n\nReport saved as:\n{output_csv_name}\n\nOpening HTML report..."
        )
        # Open the generated HTML file in the default browser
        webbrowser.open_new_tab('file://' + os.path.realpath(output_html_full_path))
        
    except Exception as e:
        messagebox.showerror("Execution Error", f"‚ùå Critical Error: Failed to create HTML report or open browser: {e}")


# --- Script Execution ---

if __name__ == "__main__":
    try:
        root = tk.Tk()
        root.withdraw() 
    except Exception:
        pass 
        
    file_path = select_file()
    
    if file_path:
        analyze_and_report_errors(file_path)
